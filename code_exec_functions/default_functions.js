const { Tokens } = require("../constants.js");
const { Token } = require("../tokenizer.js");
const pUtils = require("../utils/parser_utils.js");

/**
 * Writes an array of strings to the output file.
 * This function should not be called internally, 
 * as this function must be bound to the right context.
 * @param  {...string} str 
 */
function write(...str) {
    for (var mStr of str) {
        var token = new Token(Tokens.ANY).initFrom(this.cRefToken).withData(mStr);
        this.ctx.parser.tokenizer.queueToken(token);
    }
}

/**
 * Interprets an array of strings and writes it to the output file.
 * This function should not be called internally, 
 * as this function must be bound to the right context.
 * @param  {...string} str 
 */
function interpret(str) {
    var tokens = pUtils.tokenizeSubstring(str, this.cRefToken);
    this.ctx.parser.tokenizer.queueTokens(tokens);
}

/**
 * Writes a matrix to the output file.
 * This function should not be called internally, 
 * as this function must be bound to the right context.
 * @param  {any[]} str
 * @param  {string} type the type of the matrix
 */
function matrix(matrix, type="pmatrix") {
    // Binds the funtion 'write' to 'this', 
    // which is the context code-exec-functions should be bound to.
    var mwrite = write.bind(this);

    mwrite("\\begin{" + type + "}\n");
    for (var i = 0; i < matrix.length; i++) {
        if (Array.isArray(matrix[i])) {
            mwrite(matrix[i].map(el => el.toString()).join(" & "));
        } else {
            mwrite(matrix[i].toString());
        }
        mwrite("\\\\\n");
    }
    mwrite("\\end{" + type + "}\n");
}

/**
 * Generates a matrix / two-dimensional array.
 * This function should not be called internally, 
 * as this function must be bound to the right context.
 * @param {int} w the width of the matrix
 * @param {int} h the height of the matrix
 * @param {function(int, int): any[][]} gen the generator function
 * @returns the matrix generated by the given generator-function
 */
function mgen(w, h, gen = (i, j) => 1) {
    return Array.apply(null, Array(h)).map((x, i) => Array.apply(null, Array(w)).map((y, j) => gen(i, j)));
}

/**
 * Generates all code-exec-functions implemented in this file.
 * This function is required for the code-exec-loader to recognize the module and should not be called manually.
 * @returns a map of commands
 */
function generate() {
    return {
        "write": write,
        "interpret": interpret,
        "matrix": matrix,
        "mgen": mgen
    };
}

exports.generate = generate;