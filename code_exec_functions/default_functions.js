module.exports = function(env) {
    const path = require('path');
    const { Tokens } = require(path.join(env.base, "constants.js"));
    const { Token, Tokenizer } = require(path.join(env.base, "tokenizer.js"));
    const pUtils = require(path.join(env.base, "utils", "parser_utils.js"));
    
    /**
     * Writes an array of strings to the output file.
     * This function should not be called internally, 
     * as this function must be bound to the right context.
     * @param  {...string} str 
     */
    function write(...str) {
        for (var mStr of str) {
            var token = new Token(Tokens.ANY).initFrom(this.cRefToken).withData(mStr);
            this.ctx.parser.tokenizer.queueToken(token);
        }
    }
    
    /**
     * Interprets an array of strings and writes it to the output file.
     * This function should not be called internally, 
     * as this function must be bound to the right context.
     * @param  {...string} str 
     */
    function interpret(str) {
        var subParser = this.ctx.parser.newInstance();
        var tokenizer = new Tokenizer(str);
        var dat = subParser.parse(tokenizer);
        write.bind(this)(dat);
    }
    
    /**
     * Writes a matrix to the output file.
     * This function should not be called internally, 
     * as this function must be bound to the right context.
     * @param  {any[]} str
     * @param  {string} type the type of the matrix
     */
    function matrix(matrix, type="pmatrix") {
        // Binds the funtion 'write' to 'this', 
        // which is the context code-exec-functions should be bound to.
        var mwrite = write.bind(this);
    
        mwrite("\\begin{" + type + "}\n");
        for (var i = 0; i < matrix.length; i++) {
            if (Array.isArray(matrix[i])) {
                mwrite(matrix[i].map(el => el.toString()).join(" & "));
            } else {
                mwrite(matrix[i].toString());
            }
            mwrite("\\\\\n");
        }
        mwrite("\\end{" + type + "}\n");
    }
    
    /**
     * Generates a matrix / two-dimensional array.
     * This function should not be called internally, 
     * as this function must be bound to the right context.
     * @param {int} w the width of the matrix
     * @param {int} h the height of the matrix
     * @param {function(int, int): any[][]} gen the generator function
     * @returns the matrix generated by the given generator-function
     */
    function mgen(w, h, gen = (i, j) => 1) {
        return Array.apply(null, Array(h)).map((x, i) => Array.apply(null, Array(w)).map((y, j) => gen(i, j)));
    }

    function topdowntree(nodes, ...lvldistmm) {
        var mwrite = write.bind(this);
        mwrite("\n\\begin{tikzpicture}\n");
        for (var i = 0; i < lvldistmm.length; i++)
            mwrite("\t\\tikzstyle{level " + (i+1) + "}=[sibling distance=" + lvldistmm[i] + "mm]\n");
        mwrite("\t\\node\n");
        var nodeToString = function(node) {
            if (node == null) {
                return "edge from parent[draw=none]";
            }
            return "node [draw] {" + node + "}";
        }
        mwrite("\t[draw,] {" + (nodes[0] == null ? "" : nodes[0]) + "}");
        var writeRecursively = function(index, layer) {
            var tabs = "";
            for (var i = 0; i < layer; i++)
                tabs += "\t";
            mwrite("\n" + tabs + "child{" + nodeToString(nodes[index]));
            var leftIdx = 2 * index + 1;
            var rightIdx = 2 * index + 2;
            if (leftIdx < nodes.length) {
                writeRecursively(leftIdx, layer + 1);
            }
            if (rightIdx < nodes.length) {
                writeRecursively(rightIdx, layer + 1);
            }
            mwrite("}");
        }

        if (nodes.length > 0) {
            writeRecursively(1, 2);
        }
        if (nodes.length > 1) {
            writeRecursively(2, 2);
        }
        mwrite(";");
        mwrite("\n\\end{tikzpicture}\n");
    }
    
    /**
     * Generates all code-exec-functions implemented in this file.
     * This function is required for the code-exec-loader to recognize the module and should not be called manually.
     * @returns a map of commands
     */
    return {
        "write": write,
        "interpret": interpret,
        "matrix": matrix,
        "mgen": mgen,
        "topdowntree": topdowntree
    };
}